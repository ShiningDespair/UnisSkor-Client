{"ast":null,"code":"const type = require('./type');\nconst {\n  log,\n  pow,\n  floor,\n  abs\n} = Math;\nconst analyze = (data, key = null) => {\n  const r = {\n    min: Number.MAX_VALUE,\n    max: Number.MAX_VALUE * -1,\n    sum: 0,\n    values: [],\n    count: 0\n  };\n  if (type(data) === 'object') {\n    data = Object.values(data);\n  }\n  data.forEach(val => {\n    if (key && type(val) === 'object') val = val[key];\n    if (val !== undefined && val !== null && !isNaN(val)) {\n      r.values.push(val);\n      r.sum += val;\n      if (val < r.min) r.min = val;\n      if (val > r.max) r.max = val;\n      r.count += 1;\n    }\n  });\n  r.domain = [r.min, r.max];\n  r.limits = (mode, num) => limits(r, mode, num);\n  return r;\n};\nconst limits = (data, mode = 'equal', num = 7) => {\n  if (type(data) == 'array') {\n    data = analyze(data);\n  }\n  const {\n    min,\n    max\n  } = data;\n  const values = data.values.sort((a, b) => a - b);\n  if (num === 1) {\n    return [min, max];\n  }\n  const limits = [];\n  if (mode.substr(0, 1) === 'c') {\n    // continuous\n    limits.push(min);\n    limits.push(max);\n  }\n  if (mode.substr(0, 1) === 'e') {\n    // equal interval\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      limits.push(min + i / num * (max - min));\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'l') {\n    // log scale\n    if (min <= 0) {\n      throw new Error('Logarithmic scales are only possible for values > 0');\n    }\n    const min_log = Math.LOG10E * log(min);\n    const max_log = Math.LOG10E * log(max);\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      limits.push(pow(10, min_log + i / num * (max_log - min_log)));\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'q') {\n    // quantile scale\n    limits.push(min);\n    for (let i = 1; i < num; i++) {\n      const p = (values.length - 1) * i / num;\n      const pb = floor(p);\n      if (pb === p) {\n        limits.push(values[pb]);\n      } else {\n        // p > pb\n        const pr = p - pb;\n        limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n      }\n    }\n    limits.push(max);\n  } else if (mode.substr(0, 1) === 'k') {\n    // k-means clustering\n    /*\n    implementation based on\n    http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n    simplified for 1-d input values\n    */\n    let cluster;\n    const n = values.length;\n    const assignments = new Array(n);\n    const clusterSizes = new Array(num);\n    let repeat = true;\n    let nb_iters = 0;\n    let centroids = null;\n\n    // get seed values\n    centroids = [];\n    centroids.push(min);\n    for (let i = 1; i < num; i++) {\n      centroids.push(min + i / num * (max - min));\n    }\n    centroids.push(max);\n    while (repeat) {\n      // assignment step\n      for (let j = 0; j < num; j++) {\n        clusterSizes[j] = 0;\n      }\n      for (let i = 0; i < n; i++) {\n        const value = values[i];\n        let mindist = Number.MAX_VALUE;\n        let best;\n        for (let j = 0; j < num; j++) {\n          const dist = abs(centroids[j] - value);\n          if (dist < mindist) {\n            mindist = dist;\n            best = j;\n          }\n          clusterSizes[best]++;\n          assignments[i] = best;\n        }\n      }\n\n      // update centroids step\n      const newCentroids = new Array(num);\n      for (let j = 0; j < num; j++) {\n        newCentroids[j] = null;\n      }\n      for (let i = 0; i < n; i++) {\n        cluster = assignments[i];\n        if (newCentroids[cluster] === null) {\n          newCentroids[cluster] = values[i];\n        } else {\n          newCentroids[cluster] += values[i];\n        }\n      }\n      for (let j = 0; j < num; j++) {\n        newCentroids[j] *= 1 / clusterSizes[j];\n      }\n\n      // check convergence\n      repeat = false;\n      for (let j = 0; j < num; j++) {\n        if (newCentroids[j] !== centroids[j]) {\n          repeat = true;\n          break;\n        }\n      }\n      centroids = newCentroids;\n      nb_iters++;\n      if (nb_iters > 200) {\n        repeat = false;\n      }\n    }\n\n    // finished k-means clustering\n    // the next part is borrowed from gabrielflor.it\n    const kClusters = {};\n    for (let j = 0; j < num; j++) {\n      kClusters[j] = [];\n    }\n    for (let i = 0; i < n; i++) {\n      cluster = assignments[i];\n      kClusters[cluster].push(values[i]);\n    }\n    let tmpKMeansBreaks = [];\n    for (let j = 0; j < num; j++) {\n      tmpKMeansBreaks.push(kClusters[j][0]);\n      tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n    }\n    tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);\n    limits.push(tmpKMeansBreaks[0]);\n    for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n      const v = tmpKMeansBreaks[i];\n      if (!isNaN(v) && limits.indexOf(v) === -1) {\n        limits.push(v);\n      }\n    }\n  }\n  return limits;\n};\nmodule.exports = {\n  analyze,\n  limits\n};","map":{"version":3,"names":["type","require","log","pow","floor","abs","Math","analyze","data","key","r","min","Number","MAX_VALUE","max","sum","values","count","Object","forEach","val","undefined","isNaN","push","domain","limits","mode","num","sort","a","b","substr","i","Error","min_log","LOG10E","max_log","p","length","pb","pr","cluster","n","assignments","Array","clusterSizes","repeat","nb_iters","centroids","j","value","mindist","best","dist","newCentroids","kClusters","tmpKMeansBreaks","v","indexOf","module","exports"],"sources":["C:/Users/mehme/OneDrive/Masaüstü/UniScore/uniscore/node_modules/chroma-js/src/utils/analyze.js"],"sourcesContent":["const type = require('./type');\nconst {log, pow, floor, abs} = Math;\n\n\nconst analyze = (data, key=null) => {\n    const r = {\n        min: Number.MAX_VALUE,\n        max: Number.MAX_VALUE*-1,\n        sum: 0,\n        values: [],\n        count: 0\n    };\n    if (type(data) === 'object') {\n        data = Object.values(data);\n    }\n    data.forEach(val => {\n        if (key && type(val) === 'object') val = val[key];\n        if (val !== undefined && val !== null && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min) r.min = val;\n            if (val > r.max) r.max = val;\n            r.count += 1;\n        }\n    });\n\n    r.domain = [r.min, r.max];\n\n    r.limits = (mode, num) => limits(r, mode, num)\n\n    return r;\n};\n\n\nconst limits = (data, mode='equal', num=7) => {\n    if (type(data) == 'array') {\n        data = analyze(data);\n    }\n    const {min,max} = data;\n    const values = data.values.sort((a,b) => a-b);\n\n    if (num === 1) { return [min,max]; }\n\n    const limits = [];\n\n    if (mode.substr(0,1) === 'c') { // continuous\n        limits.push(min);\n        limits.push(max);\n    }\n\n    if (mode.substr(0,1) === 'e') { // equal interval\n        limits.push(min);\n        for (let i=1; i<num; i++) {\n            limits.push(min+((i/num)*(max-min)));\n        }\n        limits.push(max);\n    }\n\n    else if (mode.substr(0,1) === 'l') { // log scale\n        if (min <= 0) {\n            throw new Error('Logarithmic scales are only possible for values > 0');\n        }\n        const min_log = Math.LOG10E * log(min);\n        const max_log = Math.LOG10E * log(max);\n        limits.push(min);\n        for (let i=1; i<num; i++) {\n            limits.push(pow(10, min_log + ((i/num) * (max_log - min_log))));\n        }\n        limits.push(max);\n    }\n\n    else if (mode.substr(0,1) === 'q') { // quantile scale\n        limits.push(min);\n        for (let i=1; i<num; i++) {\n            const p = ((values.length-1) * i)/num;\n            const pb = floor(p);\n            if (pb === p) {\n                limits.push(values[pb]);\n            } else { // p > pb\n                const pr = p - pb;\n                limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));\n            }\n        }\n        limits.push(max);\n\n    }\n\n    else if (mode.substr(0,1) === 'k') { // k-means clustering\n        /*\n        implementation based on\n        http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        simplified for 1-d input values\n        */\n        let cluster;\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = null;\n\n        // get seed values\n        centroids = [];\n        centroids.push(min);\n        for (let i=1; i<num; i++) {\n            centroids.push(min + ((i/num) * (max-min)));\n        }\n        centroids.push(max);\n\n        while (repeat) {\n            // assignment step\n            for (let j=0; j<num; j++) {\n                clusterSizes[j] = 0;\n            }\n            for (let i=0; i<n; i++) {\n                const value = values[i];\n                let mindist = Number.MAX_VALUE;\n                let best;\n                for (let j=0; j<num; j++) {\n                    const dist = abs(centroids[j]-value);\n                    if (dist < mindist) {\n                        mindist = dist;\n                        best = j;\n                    }\n                    clusterSizes[best]++;\n                    assignments[i] = best;\n                }\n            }\n\n            // update centroids step\n            const newCentroids = new Array(num);\n            for (let j=0; j<num; j++) {\n                newCentroids[j] = null;\n            }\n            for (let i=0; i<n; i++) {\n                cluster = assignments[i];\n                if (newCentroids[cluster] === null) {\n                    newCentroids[cluster] = values[i];\n                } else {\n                    newCentroids[cluster] += values[i];\n                }\n            }\n            for (let j=0; j<num; j++) {\n                newCentroids[j] *= 1/clusterSizes[j];\n            }\n\n            // check convergence\n            repeat = false;\n            for (let j=0; j<num; j++) {\n                if (newCentroids[j] !== centroids[j]) {\n                    repeat = true;\n                    break;\n                }\n            }\n\n            centroids = newCentroids;\n            nb_iters++;\n\n            if (nb_iters > 200) {\n                repeat = false;\n            }\n        }\n\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = {};\n        for (let j=0; j<num; j++) {\n            kClusters[j] = [];\n        }\n        for (let i=0; i<n; i++) {\n            cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        let tmpKMeansBreaks = [];\n        for (let j=0; j<num; j++) {\n            tmpKMeansBreaks.push(kClusters[j][0]);\n            tmpKMeansBreaks.push(kClusters[j][kClusters[j].length-1]);\n        }\n        tmpKMeansBreaks = tmpKMeansBreaks.sort((a,b)=> a-b);\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i=1; i < tmpKMeansBreaks.length; i+= 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && (limits.indexOf(v) === -1)) {\n                limits.push(v);\n            }\n        }\n    }\n    return limits;\n}\n\nmodule.exports = {analyze, limits};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}